# link_shortener
Тестовое задание: написать API, которое будет принимать полную ссылку и возвращать сокращенную

<b>Требуется написать REST API используя любой удобный фреймворк (предпочтительно flask/DRF/aiohttp).
API должен сокращать ссылки и предоставлять к ним доступ, а так же давать возможность удаления и т.д.
Ссылки должны храниться в БД. БД может быть абсолютно любой, SQL/NoSQL.

Необязательная часть, но приветствуется.
Написать необходимые скрипты, чтоб все разворачивалось через docker-compose.</b>

Heroku: <a href="https://git-link-shortner.herokuapp.com/">git-link-shortner.herokuapp.com/</a><br>
Docker(windows): 
1. Собрать контейнер compile_container.bat или ``docker build -t link_shortener:v0.1 /путь/к/папке_содержащей_Dockerfile``
2. Запустить образ start_docker.bat или ``docker run -d -p 5000:5000 link_shortener:v0.1``
<br>
<br>
API имеет следующие эндпоинты:
/api - Принимает POST, DELETE, PUT:
1. POST - для добавления ссылок в базу и возврат короткой ссылки в ответе.<br>
  Запрос: ``{"link": ссылка_для_сокращения}``<br>
  Ответ: ``{"short link": сокращенная_ссылка}``<br>
  
  Если запись уже есть в базе, возвращает код 400
  Если запрос сформирован неправильно, возвращает код 422
  
2. DELETE для удаления ссылок из базы с обращением по ссылке<br>
  Запрос: ``{"link": ссылка_для_сокращения}``<br>
  Ответ: ``{"message": "Ссылка удалена!"}``<br>
  
  Если записи нет в базе, возвращает код 400
  
3. PUT для изменения ссылки<br>
  Запроса ``{"link": старая_ссылка, "new_link": новая_ссылка}``<br>
  Ответ ``{"message": "Ссылка: сокращенная_ссылка"}``<br>
  
  Если новая ссылка уже существует, возвращает ответ короткую ссылку от уже существующей
  Если новая ссылка не существует, создает новую ссылку и удает старую
  Если старая ссылка не существует, возвращает код 400
  
Для удобства использования на страницах "/" и "/index" находится swagger, в котором можно посмотреть какие запросы и куда можно сделать


Что не получилось:
Генератор документации возвращает некорректные схемы из-за использования одного и того же параметра для apispec.use_kwargs(валидатор параметров для входящих запросов). И данные валидируются и обрабатываются корректно, но сама документация содержит неправильные поля.
