# link_shortener
Тестовое задание: написать API, которое будет принимать полную ссылку и возвращать сокращенную

<b>Требуется написать REST API используя любой удобный фреймворк (предпочтительно flask/DRF/aiohttp).
API должен сокращать ссылки и предоставлять к ним доступ, а так же давать возможность удаления и т.д.
Ссылки должны храниться в БД. БД может быть абсолютно любой, SQL/NoSQL.

Необязательная часть, но приветствуется.
Написать необходимые скрипты, чтоб все разворачивалось через docker-compose.</b>

Heroku: <a href="https://git-link-shortner.herokuapp.com/">git-link-shortner.herokuapp.com/</a><br>
Docker(windows): 
1. Собрать контейнер через <b>compile_container.bat</b> или  
``docker build -t link_shortener:v0.1 /путь/к/папке_содержащей_Dockerfile``
2. Запустить образ через <b>start_docker.bat</b> или  
``docker run -d -p 5000:5000 link_shortener:v0.1``
<br>

Проверка работоспособности(Docker):   
POST:  
``curl --header "Content-Type: application/json" --request POST -d '{"link": "https://yandex.ru/"}'  127.0.0.1:5000/api``<br>

PUT:  
``curl --header "Content-Type: application/json" --request PUT -d '{"link": "https://yandex.ru/", "new_link": "https://pbs.twimg.com/media/DiETscrWAAAigqv.jpg"}'  127.0.0.1:5000/api``<br>

DELETE  
``curl --header "Content-Type: application/json" --request DELETE -d '{"link": "https://pbs.twimg.com/media/DiETscrWAAAigqv.jpg"}'  127.0.0.1:5000/api``<br>

<br>
API имеет следующие эндпоинты:  
/api - Принимает POST, DELETE, PUT:  

1. POST - для добавления ссылок в базу и возврат короткой ссылки в ответе.  
  **Запрос**: ``{"link": ссылка_для_сокращения}``<br>
  **Ответ**:  ``{"short link": сокращенная_ссылка}``<br>
  
    Если запись уже есть в базе, возвращает код 400  
    Если запрос сформирован неправильно, возвращает код 422  
  
2. DELETE для удаления ссылок из базы с обращением по ссылке<br>
  **Запрос**: ``{"link": ссылка_для_сокращения}``<br>
  **Ответ**: ``{"message": "Ссылка удалена!"}``<br>
  
    Если записи нет в базе, возвращает код 400
  
3. PUT для изменения ссылки<br>
  **Запрос** ``{"link": старая_ссылка, "new_link": новая_ссылка}``<br>
  **Ответ** ``{"message": "Ссылка: сокращенная_ссылка"}``<br>
  
    Если новая ссылка уже существует, возвращает ответ короткую ссылку от уже существующей
    Если новая ссылка не существует, создает новую ссылку и удает старую
    Если старая ссылка не существует, возвращает код 400
  
Для удобства использования на страницах "/" и "/index" находится swagger, в котором можно посмотреть какие запросы и куда можно сделать
![swagger_img](https://user-images.githubusercontent.com/71926912/119221587-b9651f80-baf8-11eb-9b92-b259beace4a0.PNG)


Что не получилось:
Генератор документации возвращает некорректные схемы из-за использования одного и того же параметра для apispec.use_kwargs(валидатор параметров для входящих запросов). И данные валидируются и обрабатываются корректно, но сама документация содержит неправильные поля. Это можно исправить разбив эндпоинт /api на эндпоинты типа /api/put /api/delete со своими схемами валидации
